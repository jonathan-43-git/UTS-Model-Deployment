# -*- coding: utf-8 -*-
"""OOP Training_2702223084.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQ0Bzo2vacQjTbZlwSyNqGQG5bnZPiJE

Nama : Jonathan Christopher Gani  
NIM : 2702223084
"""

# importing necessary libraries
import pandas as pd
import numpy as np
import pickle as pkl
import statistics as sts
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import accuracy_score, classification_report

class DataHandling:
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = None
        self.input_data = None
        self.output_data = None

    def loading_data(self):
        self.data = pd.read_csv(self.file_path)

    def div_input_output(self, target_column):
        self.data = self.data.drop(columns=['Booking_ID'])  # drop kolom id
        self.input_data = self.data.drop(target_column, axis=1)
        self.output_data = self.data[target_column]

class ModelHandling:
    def __init__(self, input_data, output_data):
        self.input_data = input_data
        self.output_data = output_data
        self.create_model()
        self.x_train, self.x_test, self.y_train, self.y_test, self.y_pred = [None] * 5

    def splitting_data(self, test_size=0.2, random_state=42):
        self.x_train, self.x_test, self.y_train, self.y_test = train_test_split(
            self.input_data, self.output_data, test_size=test_size, random_state=random_state)

    def medianValue(self, column_name):
        return np.median(self.x_train[column_name].dropna())

    def modeValue(self, column_name):
        return sts.mode(self.x_train[column_name])

    def fillNA_Median(self, column_name, median_value):
        self.x_train[column_name].fillna(median_value, inplace=True)
        self.x_test[column_name].fillna(median_value, inplace=True)

    def fillNA_Mode(self, column_name, mode_value):
        self.x_train[column_name].fillna(mode_value, inplace=True)
        self.x_test[column_name].fillna(mode_value, inplace=True)

    def cleaning_duplicates(self):
        cleaned_train = pd.concat([self.x_train, self.y_train], axis=1).drop_duplicates()
        self.x_train = cleaned_train.drop(columns=self.output_data.name)
        self.y_train = cleaned_train[self.output_data.name]

        cleaned_test = pd.concat([self.x_test, self.y_test], axis=1).drop_duplicates()
        self.x_test = cleaned_test.drop(columns=self.output_data.name)
        self.y_test = cleaned_test[self.output_data.name]

    def encoding_features(self):
        one_hot_cols = ["type_of_meal_plan", "room_type_reserved", "market_segment_type"]
        one_hot_encoding = OneHotEncoder(sparse_output=False)

        train_encoded = one_hot_encoding.fit_transform(self.x_train[one_hot_cols])
        train_data = pd.DataFrame(train_encoded,
                                columns=one_hot_encoding.get_feature_names_out(one_hot_cols),
                                index=self.x_train.index)

        test_encoded = one_hot_encoding.transform(self.x_test[one_hot_cols])
        test_data = pd.DataFrame(test_encoded,
                              columns=one_hot_encoding.get_feature_names_out(one_hot_cols),
                              index=self.x_test.index)

        self.x_train_encoded  = pd.concat([self.x_train.drop(columns=one_hot_cols), train_data], axis=1)
        self.x_test_encoded  = pd.concat([self.x_test.drop(columns=one_hot_cols), test_data], axis=1)

    def encoding_target(self):
        binary_encode = {'Not_Canceled': 0, 'Canceled': 1}
        self.y_train_encoded = self.y_train.map(binary_encode)
        self.y_test_encoded = self.y_test.map(binary_encode)

    def create_model(self, n_estimators=110, random_state=42):
        self.model = RandomForestClassifier(n_estimators=n_estimators, random_state=random_state)

    def training_model(self):
        self.model.fit(self.x_train_encoded, self.y_train_encoded)

    def make_prediction(self):
        self.y_pred = self.model.predict(self.x_test_encoded)

    def model_accuracy(self):
        return accuracy_score(self.y_test_encoded, self.y_pred)

    def classification_report(self):
        print("\nClassification Report:\n", classification_report(self.y_test_encoded, self.y_pred))

    def export_model_to_pkl(self, filename):
        with open(filename, 'wb') as file:
            pkl.dump(self.model, file)

file_path = 'Dataset_B_hotel.csv'

# data handling
data_handling = DataHandling(file_path)
data_handling.loading_data()
data_handling.div_input_output('booking_status')
input_data = data_handling.input_data
output_data = data_handling.output_data

# data preprocessing and modelling
model_handling = ModelHandling(input_data, output_data)
model_handling.splitting_data()

impute_median_parking = model_handling.medianValue('required_car_parking_space')
model_handling.fillNA_Median('required_car_parking_space', impute_median_parking)
impute_median_avgprice = model_handling.medianValue('avg_price_per_room')
model_handling.fillNA_Median('avg_price_per_room', impute_median_avgprice)
impute_mode_meal = model_handling.modeValue('type_of_meal_plan')
model_handling.fillNA_Mode('type_of_meal_plan', impute_mode_meal)

model_handling.cleaning_duplicates()

model_handling.encoding_features()
model_handling.encoding_target()

model_handling.training_model()
model_handling.make_prediction()

print("Accuracy:", model_handling.model_accuracy())
model_handling.classification_report()

model_handling.export_model_to_pkl('trained_RF_model.pkl')

